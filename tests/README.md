# Tests 

This directory is for test cases for the BruinNotes application. A description of our current testing status on various features can be found below:

## UX/UI and Frontend Testing
BruinNotes aims at providing simple interfaces for users to share and request notes. Therefore, most of the testing that was done in the frontend development focused heavily on the scaling of the webpages on different devices of different aspect-ratios. To do this, we made use of the “toggle device toolbar” that is available in the inspect mode of any Google Chrome web browser. However, our web applications do not support mobile device aspect-ratios. Other aspects of testing in frontend will be described in detail below within each feature section.

## Account System (Signup)
Like every other account system web application, BruinNotes requires user input validation and user authentication. To set up an account, a user must provide:
A full name consisting of a first name and a last name, which corresponds to RegEx = “[A-Za-z]+ [A-Za-z]”
A unique UID consisting of 9 digits (RegEx = “^\\d{9}$”)
A unique UCLA email address, which is validated using another regular expression (RegEx=“^[\\w-\._]+@([\\w-]+\.)+ucla\.edu$”)
A password that consists of at least 6 characters of at least one uppercase letter, one digit, and one special symbol (!@#$%^&*) that equivalent to
RegEx=“^(?=.*[0-9])(?=.*[A-Z])(?=.*[!@#$%^&*])[a-zA-Z0-9!@#$%^&*]{6,16}$”
To verify the accuracy of our Regular Expressions listed above, we used RegExr, an online tool to build and test a RegEx. To test out each object validation, we used console.log() and alert(), to output the boolean result for observations on different user input case scenarios. One test scenario was when a user clicks on a sign up button on the Signup Page. If the inputted information matches the regular expression, then the account is created. Otherwise, an error is displayed. Therefore, we checked our test case scenario to see whether they are consistent with the result logged into the console when a user creates an account.
Checking the uniqueness of the UID and the email address requires communications between the frontend and backend through the calling of two APIs, which are GET /checkuid/{uid}, and GET /checkemail/{email}. These APIs check through the database and return boolean values as responses to whether or not they are unique. Therefore, we have to check for a scenario when a user attempts to sign up for an account using the same email address or the same UID as an existing user. To test the frontend, we made use of console.log() and alert() to observe correct behavior on two different user input case scenarios of duplicate email/UID and unique email/UID. While writing each of the backend APIs, we did incremental development paired with extensive manual testing. This ensured that each of the functions was working properly, and the changes were being propagated to the MongoDB database.
The success of signing up relies on the POST /adduser API that adds the inputted information into the database. Therefore, we can check MongoDB to check whether the information in the database is updated.  

## Account System (Login)
For login, we must verify if the UIDs and the passwords inputted by users match the one they used to create their accounts for authentication purposes. To do this, we made use of the POST /checkpassword API. This API takes in a dict consisting of the inputted user information, and checks whether it matches the information in the database. If so, it returns true and the login attempt is successful. Otherwise, it returns false and the login fails. Like before, for testing, we used console.log() and alert() to test the two scenarios that can happen (password matches or doesn’t match) for both frontend and backend testing.

## Account System (Forget Password)
In a third possible scenario when users forget their password, then the user must go through a process to verify their email and change the passwords for their accounts. The testing is done through checking whether an email is sent on the send verification button clicked, and if the password value is updated in the database, if the users successfully verified their email. We made use of Dylan Phe’s UCLA email to do that.

## Search System 
For the search system we allow users to search for the class that applies to them. There will be a dropdown menu that the user can interact with and choose the class from a series of options and possibly search for them too as the list gets long. Each time a user needs to add a new class to the search system, they will be able to enter a new page to add the item into the list. 
If the item exists already it will be compared against a list of existing classes that have been entered in the system and not allow for the user to enter that class as a “new class.” 

## Courses System
The course system frontend is tested manually with relevant json data defined in the frontend and manual user inputs. 
For displaying the course data, one test case scenario is no professor or term is recorded for the course. The outcome for test success is displaying a message that encourages the user to add a professor to that course. Another test case scenario is that a professor exists for the course, but no term is associated with that professor. The outcome for test success is displaying the professor but no term below it, as demonstrated in the course page screenshot in section 1.4. For the case where professors and terms are present, the successful outcome is displaying both professors and their terms as indicated in the screenshot; if more than one professor is displayed, each professor’s background color is assigned iteratively among 6 available colors. When the backend communication is implemented, the expected outcome should be correctly displaying all course data on the webpage. For each test case above, outcomes for test failure include incorrect rendering of the page, incorrect display of information, mismatching colors, as well as error or warning messages in the console. 
Tests that involve user interactions include pressing buttons, toggling popup modals, and user inputs. One test case scenario is the user clicks the “add professors and quarter” button on the course page, then a popup form is displayed, and then the user clicks somewhere outside the form or clicks the close button on the form. The successful outcome is the form pops up after the first click and disappears after the second click. In the scenario that the user fills out the form and clicks the submit button with all required and valid input, the expected successful outcome would be displaying the newly inputted information in descending order of time. A failed outcome would include unsuccessful rendering of the page, unsuccessful closure of the popup modal, incorrect display of the new information, as well as errors and warnings in the console. In that form, the user can choose to enter a new professor or enter a quarter for an existing professor. A successful outcome would also require these two choices to be mutually exclusive. In the case that the user submits missing or invalid information, such as inputting 202.2 for the year, the expected outcome would continue to show the popup form with all existing inputs and highlight the missing or invalid fields. Outcomes of test failure include disappearance of the popup and the inputs, lack of indicators for invalid fields, and form submission with erroneous inputs.

## Frontend and Backend Communication Testing
Our web application utilizes RESTful API’s to communicate from the React frontend to the FastAPI python backend. Once the backend receives data, such as user information, we can insert that data into our MongoDB cluster.

In order to test this data communication from client to backend to MongoDB, we have created logs along every step. Client logs the post request in the browser console, FastAPI backend logs the HTTP status code and content in the local console, and MongoDB data can be viewed directly in the GUI. The following figures show the process we take for testing.